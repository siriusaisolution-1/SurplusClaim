// Prisma schema defining multitenant data model for Surplus Claim
// Database: PostgreSQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  SUPER_ADMIN
  TENANT_ADMIN
  REVIEWER
  OPS
  B2B_CLIENT
  READ_ONLY
}

enum CaseStatus {
  DISCOVERED
  TRIAGED
  CLIENT_CONTACTED
  CONSENT_SIGNED
  DOCUMENT_COLLECTION
  PACKAGE_READY
  SUBMITTED_BY_CLIENT
  SUBMITTED_BY_PARTNER
  AWAITING_RESPONSE
  SUBMITTED
  PAYOUT_CONFIRMED
  CLOSED
  ESCALATED
  ON_HOLD
}

enum TierLevel {
  LOW
  MEDIUM
  HIGH
  ENTERPRISE
}

enum CommunicationDirection {
  INBOUND
  OUTBOUND
}

enum CommunicationChannel {
  EMAIL
  SMS
}

enum LegalExecutionMode {
  ATTORNEY_REQUIRED
  OPS_DIRECT
}

model Tenant {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name        String
  createdAt   DateTime @default(now()) @db.Timestamptz
  updatedAt   DateTime @updatedAt @db.Timestamptz

  users           User[]
  cases           Case[]
  feeAgreements   FeeAgreement[]
  invoices        Invoice[]
  auditLogEntries AuditLog[]
  caseEvents      CaseEvent[]
  artifacts       Artifact[]
  documents       Document[]
  consents        Consent[]
  communications  Communication[]
  payouts         Payout[]
  sessions        Session[]
  attorneys       Attorney[]

  @@unique([name])
}

model User {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  email     String
  fullName  String
  passwordHash String @default("")
  role      UserRole
  createdAt DateTime @default(now()) @db.Timestamptz
  updatedAt DateTime @updatedAt @db.Timestamptz

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  casesAssigned Case[] @relation("CaseReviewer")
  auditEntries  AuditLog[] @relation("AuditActor")
  sessions Session[]
  payoutsConfirmed Payout[] @relation("PayoutConfirmedBy")

  @@unique([tenantId, email], map: "user_tenant_email_unique")
  @@index([tenantId, role], map: "user_tenant_role_idx")
}

model Case {
  id                 String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId           String    @db.Uuid
  caseRef            String
  status             CaseStatus
  tierSuggested      TierLevel
  tierConfirmed      TierLevel?
  assignedReviewerId String?   @db.Uuid
  assignedAttorneyId String?   @db.Uuid
  legalExecutionMode LegalExecutionMode @default(ATTORNEY_REQUIRED)
  expectedPayoutWindow String?
  closureConfirmationRequired Boolean @default(false)
  metadata           Json?
  createdAt          DateTime  @default(now()) @db.Timestamptz
  updatedAt          DateTime  @updatedAt @db.Timestamptz

  tenant           Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  assignedReviewer User?  @relation("CaseReviewer", fields: [assignedReviewerId], references: [id], onDelete: SetNull, onUpdate: NoAction, map: "case_assigned_reviewer_fk")
  assignedAttorney Attorney? @relation("CaseAttorney", fields: [assignedAttorneyId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  events           CaseEvent[]
  artifacts        Artifact[]
  documents        Document[]
  consents         Consent[]
  communications   Communication[]
  payouts          Payout[]
  invoices         Invoice[]
  auditTrail       AuditLog[]

  @@unique([tenantId, caseRef], map: "case_tenant_ref_unique")
  @@index([tenantId, status], map: "case_tenant_status_idx")
  @@index([tenantId, caseRef], map: "case_tenant_ref_idx")
  @@index([tenantId, assignedAttorneyId], map: "Case_tenantId_assignedAttorneyId_idx")
}

model Attorney {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  fullName  String
  email     String?
  phone     String?
  barNumber String?
  createdAt DateTime @default(now()) @db.Timestamptz
  updatedAt DateTime @updatedAt @db.Timestamptz

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  cases  Case[] @relation("CaseAttorney")

  @@unique([tenantId, email], map: "Attorney_tenantId_email_key")
  @@index([tenantId, barNumber], map: "Attorney_tenantId_barNumber_idx")
}

model CaseEvent {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  caseId    String   @db.Uuid
  caseRef   String
  type      String
  payload   Json
  createdAt DateTime @default(now()) @db.Timestamptz
  processedAt DateTime? @db.Timestamptz

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([tenantId, caseRef], map: "case_event_tenant_ref_idx")
}

model AuditLog {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  caseId    String?  @db.Uuid
  caseRef   String
  actorId   String?  @db.Uuid
  action    String
  metadata  Json?
  hash      String
  prevHash  String?
  createdAt DateTime @default(now()) @db.Timestamptz

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  case   Case?  @relation(fields: [caseId], references: [id], onDelete: SetNull, onUpdate: NoAction)
  actor  User?  @relation("AuditActor", fields: [actorId], references: [id], onDelete: SetNull, onUpdate: NoAction)

  @@unique([tenantId, hash], map: "audit_hash_unique")
  @@index([tenantId, caseRef], map: "audit_tenant_ref_idx")
}

model Artifact {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId   String   @db.Uuid
  caseId     String   @db.Uuid
  caseRef    String
  objectKey  String
  sha256     String
  source     String?
  createdAt  DateTime @default(now()) @db.Timestamptz

  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  case    Case    @relation(fields: [caseId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  consent Consent? @relation("ConsentArtifact")

  @@index([tenantId, caseRef], map: "artifact_tenant_ref_idx")
  @@unique([tenantId, objectKey], map: "artifact_object_unique")
}

model Document {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  caseId    String   @db.Uuid
  caseRef   String
  objectKey String
  originalFilename String
  sha256    String
  docType   String?
  aiDocType String?
  aiConfidence Float?
  status    DocumentStatus @default(PENDING)
  reviewerId String?  @db.Uuid
  reviewedAt DateTime? @db.Timestamptz
  reviewNote String?
  createdAt DateTime @default(now()) @db.Timestamptz

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([tenantId, caseRef], map: "document_tenant_ref_idx")
  @@unique([tenantId, objectKey], map: "document_object_unique")
}

enum DocumentStatus {
  PENDING
  APPROVED
  REJECTED
}

model Consent {
  id                 String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId           String    @db.Uuid
  caseId             String    @db.Uuid
  caseRef            String
  consentVersion     String
  consentArtifactId  String?   @unique @db.Uuid
  signedAt           DateTime @db.Timestamptz
  revokedAt          DateTime? @db.Timestamptz

  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  case     Case     @relation(fields: [caseId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  artifact Artifact? @relation("ConsentArtifact", fields: [consentArtifactId], references: [id], onDelete: SetNull, onUpdate: NoAction)

  @@index([tenantId, caseRef], map: "consent_tenant_ref_idx")
}

model Communication {
  id          String                  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId    String                  @db.Uuid
  caseId      String                  @db.Uuid
  caseRef     String
  templateId  String?
  templateVersion String?
  recipient   String?
  variables   Json?
  subject     String
  body        String
  direction   CommunicationDirection
  channel     CommunicationChannel
  status      String
  sendAt      DateTime                @default(now()) @db.Timestamptz
  providerMessageId String?
  createdAt   DateTime @default(now()) @db.Timestamptz

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([tenantId, caseRef], map: "communication_tenant_ref_idx")
  @@index([tenantId, status], map: "communication_tenant_status_idx")
}

model Payout {
  id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId       String   @db.Uuid
  caseId         String   @db.Uuid
  caseRef        String
  amountCents    Int
  currency       String   @default("USD")
  status         String
  reference      String?
  processedAt    DateTime? @db.Timestamptz
  confirmedAt    DateTime? @db.Timestamptz
  confirmedBy    String?  @db.Uuid
  evidenceKey    String?
  feeCents       Int?
  feeRateBps     Int?
  metadata       Json?
  createdAt      DateTime @default(now()) @db.Timestamptz

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  confirmedByUser User? @relation("PayoutConfirmedBy", fields: [confirmedBy], references: [id], onDelete: SetNull, onUpdate: NoAction)
  invoice Invoice? @relation("InvoicePayout")

  @@index([tenantId, caseRef], map: "payout_tenant_ref_idx")
  @@index([tenantId, status], map: "payout_tenant_status_idx")
}

model FeeAgreement {
  id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId       String   @db.Uuid
  tierMin        TierLevel
  tierMax        TierLevel
  capAmountCents Int?
  minFeeCents    Int?
  b2bOverride    Int?
  stateCode      String?
  contractRef    String?
  notes          String?
  createdAt      DateTime @default(now()) @db.Timestamptz
  updatedAt      DateTime @updatedAt @db.Timestamptz

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([tenantId, tierMin, tierMax], map: "fee_agreement_tier_idx")
  @@index([tenantId, stateCode], map: "fee_agreement_state_idx")
  @@index([tenantId, contractRef], map: "fee_agreement_contract_idx")
}

model Invoice {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId    String   @db.Uuid
  caseId      String   @db.Uuid
  caseRef     String
  payoutId    String?  @unique(map: "Invoice_payoutId_key") @db.Uuid
  amountCents Int
  feeRateBps  Int?
  currency    String   @default("USD")
  status      String   @default("PENDING")
  issuedAt    DateTime @default(now()) @db.Timestamptz
  dueAt       DateTime? @db.Timestamptz
  metadata    Json?
  createdAt   DateTime @default(now()) @db.Timestamptz

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  payout Payout? @relation("InvoicePayout", fields: [payoutId], references: [id], onDelete: SetNull, onUpdate: NoAction)

  @@index([tenantId, caseRef], map: "invoice_tenant_ref_idx")
  @@index([tenantId, status], map: "invoice_tenant_status_idx")
}

model Session {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId         String   @db.Uuid
  userId           String   @db.Uuid
  refreshTokenHash String
  expiresAt        DateTime @db.Timestamptz
  createdAt        DateTime @default(now()) @db.Timestamptz
  revokedAt        DateTime? @db.Timestamptz

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@index([tenantId, userId], map: "Session_tenantId_userId_idx")
  @@unique([refreshTokenHash], map: "Session_refreshTokenHash_key")
}
